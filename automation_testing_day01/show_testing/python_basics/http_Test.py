#!/usr/bin/env python
#-*- coding:utf-8 -*-
# author: Peng Chao
'''
HTTP请求流程：
1.client:客户端建立与服务器（server）的链接
2.client-->发送请求-->服务端（request）
3.server-->接收请求-->响应给客户端（response）
4.client-->关闭TCP的链接
Cookie的工作流程：
1.客户端发送请求到服务端
2.服务端响应回复，set-cookie记录下客户端的信息
3.客户端带上Cookie的信息再次向服务器发起请求
4.服务器找到对应的信息，响应给客户端
session工作流程：
1.客户端发送请求，服务端接收到后，set-cookie记录下sessionID同事存储在服务端
2.存储成功后，返回给客户端
3.客户端再次请求，Cookie中带着sessionID，发送给服务端
4.服务端接收到cookie中带的sessionID，与服务端存储的sessionID进行对比判断，是否一致
5.一致的情况下，依据sessionID返回用户的信息


HTTP 1.0/HTTP 1.1默认是持久链接
一般就是keep-alive
URI：唯一标识并且定位信息资源

拆解：
http://103.6.223.203:8010/SysUser/Operator
协议：http：//
服务器：103.6.223.203：8010
资源：/SysUser/Operator

HTTP常用方法：
1.（查）get：（客户端向服务端请求资源，服务端向客户端发送资源）用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
2.（增）post：客户端数据发送到服务网关应用程序  客户端发送post请求给服务器，会提交数据，服务端保证数据存储，
并且完整的保存下来，同时保证不出现重复的数据
3.（改）put：来自客户端的数据存储到服务器资源，就会覆盖（更新）
4.（删）delete：在服务器删除资源


1、GET方法与POST方法的区别
GET方法：
使用GET方法时，查询字符串（键值对）被附加在URL地址后面一起发送到服务器：
/test/demo_form.jsp?name1=value1&name2=value2
特点：
GET请求能够被缓存
GET请求会保存在浏览器的浏览记录中
以GET请求的URL能够保存为浏览器书签
GET请求有长度限制
GET请求主要用以获取数据
POST方法：
使用POST方法时，查询字符串在POST信息中单独存在，和HTTP请求一起发送到服务器：
POST /test/demo_form.jsp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
特点：
POST请求不能被缓存下来
POST请求不会保存在浏览器浏览记录中
以POST请求的URL无法保存为浏览器书签
POST请求没有长度限制

区别一（使用场景）：
get重点在从服务器上获取资源，post重点在向服务器发送数据；
区别二（请求数据位置）：
get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，
多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，
这个过程用户是可见的；
post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
区别三（请求数据大小）：
Get传输的数据量小，因为受URL长度限制，但效率较高；
Post可以传输大量数据，所以上传文件时只能用Post方式；
区别四（安全性）：
get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；
post较get安全性较高；
区别五（编码集合）：
get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
post支持标准字符集，可以正确传递中文字符。
区别六（共享性）：
get请求的请求数据在url中，便于分享连接，可以添加到书签，而post请求不可以。。
区别七（缓存）：
get请求能被缓存，而post请求不行。
区别八（表单重复提交）：
点击返回/刷新按钮，对get请求没有影响，对于post请求可能会导致数据重发（浏览器会提示）。

HTTP8种请求方式：
HTTP请求的方法：
HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式

1、OPTIONS
返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性
2、HEAD
向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。
这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
3、GET
向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，
其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url
4、POST
向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。
POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：
web_submit_data,web_submit_form
5、PUT
向指定资源位置上传其最新内容
6、DELETE
请求服务器删除Request-URL所标识的资源
7、TRACE
回显服务器收到的请求，主要用于测试或诊断
8、CONNECT
HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
注意：
1）方法名称是区分大小写的，当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Mothod Not Allowed）；当服务器不认识或者不支持对应的请求方法时，应返回状态码501（Not Implemented）。
2）HTTP服务器至少应该实现GET和HEAD/POST方法，其他方法都是可选的，此外除上述方法，特定的HTTP服务器支持扩展自定义的方法。


状态码：
200：请求被正常处理
201：创建成功
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
301：永久性重定向
302：临时重定向
303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法
400：请求报文语法有误，服务器无法识别
401：请求需要认证（用户名或密码）
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源，服务端直接拒绝
500：服务器内部错误
503：服务器正忙
1. 1XX 服务器已经接收到客户端得请求，需要进一步得处理，客户端请等待
2. 2XX 处理成功
3. 3XX 重定向
4. 4XX 客户端的错误  400   401   403
5. 5XX 服务器端的错误
常用的HTTP头字段
Request方向：
Accept:接受什么介质类型
User-Agent:说明浏览器的软件类型以及版本
Accept-Charset:接收的字符串
Accept-Language:接收的语言
Cache-Control:对服务器的缓存控制
Connection:对服务器的链接控制
Host：客户端制定自己想访问的WEB服务器的域名，IP地址
Referer:浏览器向WEB服务器表明自己是从哪个URL获取当前请求种的URL
Accept-Version:指明客户端请求的软件版本号


Response方向：
Accept-Ranges:服务器表明自己是否接收
Authorization:客户端接收来自web服务器的www-authenticate
响应身份验证信息给web服务器
Cache-Control:对客户端的缓存控制
Connection:链接状态通知
Location：访问的对象已经被移到别的位置，应该到本头字段指向的地址获取
Server：指明服务器的软件类型以及版本


http协议是一种无状态协议，cookie是记录在客户端的，将我们请求的信息，明文展示出来；
session是存储在服务端的

session请求流程：
1.客户端发送请求，服务端接收到后
2.set-cookie记录下sessionID同时存储在服务端
3.存储成功后，返回给客户端
4.客户端再次请求，Cookie中带着sessionID，发送给服务端
5.服务端接收到Cookie中带着的sessionID，与服务端存储的sessionID进行判断是否一致
6.一致的情况下，依据用户的sessionID返回用户的信息
token：是session的一种行为，本质上与session相同，主要用于移动端产品
使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是这样的：
1.客户端使用用户名跟密码请求登录
2.服务端收到请求，去验证用户名与密码
3.验证成功后，服务端会签发一个 Token，再把这个 Token 返回给客户端
4.客户端拿到 Token 以后可以把它存储起来，比如放在 Cookie ,Headers，请求参数
5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token服务端收到请求，
然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据
session和token最本质的差异性是什么？
1.token是一种新技术，session是一种老技术
2.移动端没有浏览器概念，才有token的出现
3.web端用的session，移动端用的token
4.session是有有效期的

1.登录成功后，拿到session的信息 可以再次发送请求,服务端能够经过验证
2.服务端签发的token每次都不一样，请求的数据和返回的数据是不会变化的


鉴权：
基本认证：Basic Auth
常规认证
oauth2.0

测试套件：简单的说，就是测试用例的集合
1.变量


接口测试的断言：（断言很重要）
1.协议状态码（最怕的就是用例跑通了，结果功能还有问题。价值=0）
2.业务状态码
3.数据验证

场景是什么？
1.测试环境部署，冒烟测试（自动化用例）
2.测试环境测试OK，开发合并了代码，也需要测试（自动化去执行）
3.上线后，冒烟测试，自动化测试执行60%-75%


'''